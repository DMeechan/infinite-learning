<p>What are the layers of the OSI model?</p> 	<p>Application</p> <p>Presentation</p> <p>Session</p> <p>Transport</p> <p>Network</p> <p>Data link</p> <p>Physical</p> 
<p>What kinds of data run on each layer of the OSI model?</p> 	<p>Application - DATA</p> <p>Presentation - DATA</p> <p>Session - DATA</p> <p>Transport - SEGMENTS</p> <p>Network - PACKETS</p> <p>Data link - FRAMES</p> <p>Physical - BITS</p> 
<p>What are some example protocols / things that run on each layer of the OSI model?</p> 	<p>Application - HTTP or DNS or FTP or SSH</p> <p>Presentation - SSL or WPA</p> <p>Session - APIs or sockets</p> <p>Transport - TCP or UDP</p> <p>Network - IPv4 or IPv6</p> <p>Data link - Wi-Fi or ethernet</p> <p>Physical - cables or hubs</p> 
<p>What are four properties of HTTP?</p> 	<ol> <li>HTTP can deliver <strong>any type of data</strong></li> <li>HTTP runs on TCP/IP</li> <li>It <strong>does not maintain a connction</strong> - the server drops the connection after the request / resonse cycle is complete</li> <li>It&#39;s <strong>stateless</strong> - every request assumes no prior communication (so every request contains a bunch of headers, like for auth or whatever)</li> </ol> <p><em>Note that TCP is a connection-oriented transport protocol, whereas UDP is truly connectionless. So technically HTTP is not <code>connectionless</code>, but realistically the connection is dropped after the cycle is complete.</em></p> <p><em>Unless we use a keep-alive so we can re-use the same TCP connection for multiple requests</em></p> 
<p>What is a HTTP request made up of?</p> 	<ol> <li>Start line:  METHOD   RESOURCE_URI    HTTP_VERSION</li> <li>Header: key-value pairs, like file type, language, auth token</li> <li>Body: some content, like the details of a todo list task for a POST request</li> </ol> 
<p>What is a HTTP response made up of?</p> 	<ol> <li>Start line:  HTTP_VERSION    STATUS_CODE</li> <li>Header: some key-value pairs</li> <li>Body: the requested data, like a HTML page or JSON blob</li> </ol> 
<p>What does the HTTP request / response cycle look like?</p> 	<ol> <li>Client composes a request</li> <li>Client sends that request to the server and initiates a TCP connection</li> <li>Server accepts the TCP connection</li> <li>Server processes the request</li> <li>Server composes a response</li> <li>Server sends the response</li> <li>Server closes the TCP connection</li> </ol> <p><em>But IRL, you&#39;d probably use a keep-alive to hold the TCP connection open so you can re-use it for multiple requests</em></p> 
<p>What is a TCP connection made up of?</p> 	<p>A TCP connection is defined by two <em>endpoints</em>. These endpoints are called <em>sockets</em>.</p> <p>What is a socket? A socket is simply a network interface (IP address) + a port (like 8080)</p> <p>So can have multiple TCP connections going through one socket on a server because each connection is defined by both the client endpoint and server endpoint.</p> 
<p>How does a HTTP keep-alive work?</p> 	<p>In HTTP 0.9 and 1.0, clients had to include a <code>Connection: keep-alive</code> header in their request. If the server agreed, it wouldn&#39;t close the TCP connection after sending its response.</p> <p>Now in HTTP 1.1, <code>Connection: keep-alive</code> is the default.</p> <p>So clients must explicitily include a <code>Connection: close</code> header if they don&#39;t want the TCP connection to remain open.</p> 
<p>Why is it more efficient to use <code>keep-alives</code> than creating a new TCP connection for every request?</p> 	<p>Creating a TCP connection is expensive, so it&#39;s much faster to only perform it once.</p> <p>Creating the TCP connection involves three steps:</p> <ol> <li>DNS lookup - resolve hostname to an IP address</li> <li>TCP connection - perform a three-way handshake to create a connection</li> <li>SSL session - exchange keys to encrypt the connection and create a session</li> </ol> 
